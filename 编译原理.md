---
typora-root-url: ./
typora-copy-images-to: img
---

# 编译原理

废话：

```
md因为考研复试还得重新学这个玩意儿，当时学的时候就没学好。
不过这玩意儿好歹是有点用的，离散数学如果没过线就不学了。
```

**该笔记中的关键概念用5号标题指出。**

主要参考的是《编译原理及编译程序构造（第2版）》

> 这本书真的是一坨**，不知道为什么会有学校要用这本书。
>
> 我的建议是配合哈工大的网课食用，那个网课的质量是很不错的。

## 第一章 引论

翻译：从一种语言转化为另一种语言

编译：从高级语言转换为低级语言

流程如下：

![image-20230105223352632](/img/image-20230105223352632.png)

##### 词法分析

词法分析就是扫描源程序字符串，按词法规则识别出正确的单词，并转换成统一规格（类号，内码）交语法分析使用。

##### 语法分析

语法分析阶段的任务是组词成句，构造语法树。有两种方法：推导（derive）和归约（reduce）。

推导是从文法推出句子，归约则相反。

##### 中间代码生成

在语法分析正确的基础上，按照相应的语义规则产生一种介于源语言与目标语言之间的代码，这种代码不依赖于机器但又便于产生依赖于机器的目标代码。

主要的形式有：四元式、三元式和逆波兰式。

##### 优化

对中间代码进行加工变化（优化），变得高效。

##### 目标代码生成

把中间代码转换为具体的机器指令序列。



### 一些关键的表格

符号表，常数表，标号表，分程序入口表，中间代码表...



## 第二章 编译基础知识

##### 字母表

**字母表**是<u>符号</u>的非空有穷集合。<u>符号</u>是语言中最基本的不可再分单位。

##### 符号串

**符号串**是字母表中<u>符号</u>组成的有穷序列。

### 符号串集合的运算

乘积：
![image-20230106100013067](/img/image-20230106100013067.png)

##### 前缀、后缀、子串

前缀就是从尾部去掉若干字符（包括0个）

后缀就是从头部去掉若干字符。

子串就是去掉一个前缀和以后后缀剩下来的。

##### 闭包和正闭包

<u>字母表</u>A的闭包是字母表A的各次方幂之并集。

正闭包不包括空串。



### 文法术语

![image-20230106100823427](/img/image-20230106100823427.png)

![image-20230106100700669](/img/image-20230106100700669.png)

##### 非终结符Vn

尖括号括起来的词乘坐语法成分或语法实体。

出现在规则左部的符号称作非终结符。

##### 终结符Vt

语言中不可再分割的字符串，是组成句子的基本单位。

##### 开始符号

是一个特殊的非终结符号，它表示了所定义的是什么样的语法范畴。

##### 产生式

产生式是用来定义符号串之间关系的一组规则（语法规则），如下：

![image-20230106101109419](/img/image-20230106101109419.png)

##### 推导和归约

使用产生式右部取代左部的过程称为推导。

用左部取代右部的过程称作归约。

### 文法和语言的形式定义

文法分类，跟鬼一样。

![image-20230106102314336](/img/image-20230106102314336.png)

![image-20230106102525126](/img/image-20230106102525126.png)

![image-20230106102533385](/img/image-20230106102533385.png)



### 语法树和文法二义性

##### 二义性

如果文法的一个句子存在对应两棵或两棵以上的语法树。则该句子是二义的，包含二义句子的文法是二义文法。

*文法的二义性是不可判定的，只能举反例。*



## 第三章 词法分析

基础理论是有限自动机理论。

有限自动机理论与正规文法、正规式三者之间在描述语言方面有一一对应的关系。

### 正规文法

又称Chomsky3型文法

![image-20230110132403335](/img/image-20230110132403335.png)

由正规文法产生的语言称为正规集，正规集可以用正规式表示。【其实吧正规式就是和正则表达式差不多的东西】

例子如下：

![image-20230110133158866](/img/image-20230110133158866.png)

### 有限自动机(FA)【关键】

![image-20230110134015795](/img/image-20230110134015795.png)

##### 确定有限自动机DFA

> Deterministic Finite Automata
>
> 确定性表现在每次状态的转换是唯一确定的。

是一个五元组M=(S, ∑,f,s0,Z)

S: 有限状态集，元素为一个状态

∑：有穷字母表，元素为输入字符

f: 状态转换的映射

s0: 初始状态

Z: 终止状态，可为空集

例子如下：

![image-20230110134934280](/img/image-20230110134934280.png)

![image-20230110134912718](/img/image-20230110134912718.png)

![image-20230110134555598](/img/image-20230110134555598.png)

##### 不确定有限自动机NFA

定义同DFA类似，但是f可以有多个映射，s0可以有多个。

例子如下：

![image-20230110135920536](/img/image-20230110135920536.png)

##### NFA->DFA(可能是考试重点)

NFA的确定化——子集法

![image-20230110142323111](/img/image-20230110142323111.png)

##### DFA的化简等等

这部分有很多例子，还是应该看书。



### 词法分析程序

lexer

任务：从左至右扫描源程序的字符串，按照词法规则识别出一个个正确的单词，并转换该单词成相应的二元式（类号，内码）交语法分析使用。

##### 预处理

预处理用来处理注释啥的，其实可有可无。

##### 超前搜索

*涉及少数高级语言*

有时候不确定单词什么意思，就得做个标记然后往下读，最后再退回来分析。

#### 扫描器的输出格式【关键】

单词的分类：

1. 基本字

   又称关键字/保留字。

   比如if,while...

2. 标识符

   用于标识各种名字。

   比如：变量名、数组名、函数名...

3. 常量

4. 运算符

5. 界符

   比如: , ; ?

扫描器的输出格式为二元式序列（类号，内码）

通常来说的考虑：

1. 每个基本字占一个类号

2. 各种标识符统一为一类，同时要填写符号表

   ![image-20230110182847840](/img/image-20230110182847840.png)

3. 常量

   常量按不同类型分成相应的类号，同时要设置相应的**常量表**。

4. 界符

   通常也是一个符号对应一个类号。

#### 扫描器的设计【关键】

先要写出词法规则，例如：

![image-20230110183530861](/img/image-20230110183530861.png)

然后可以画出状态转化图。

状态图只有一个初态，表示分析从一个新单词开始，有若干终态，表示识别出不同的单词。

具体的实现还是可以参考那个对接llvm的例子（虽然我在windows下并不能对接成功md）



## 第四章 自上而下的语法分析

> 关键词：
>
> 上下文无关文法（CFG）
>
> 下推自动机(PDA)
>
> 这部分书上写的一坨翔，去看了看哈工大的视频（BV1zW411t7YE）

##### 自顶向下

从语法树顶部S推出词串w的过程。（推导）

##### 最左推导

在推导时总是选择每个句型的最左非终结符进行替换。

例子：

![image-20230120141639956](/img/image-20230120141639956.png)

与之相反的自底向上的过程称为——最右归约

##### 规范推导/归约

最左归约称为规范归约。

最右推导称为规范推导。

<u>**但是！由于分析器都是自左向右扫描字符串，所以，采用最左推导的方式。**</u>

![image-20230120142403744](/img/image-20230120142403744.png)







上下文无关文法 + 下推自动机 = **语法分析**的理论基础

##### 下推自动机（PDA）

![image-20230120113135351](/img/image-20230120113135351.png)

**比有限自动机多一个下推栈，对应最左推导**

PDA的动作由三个因素决定：

1. 当前所处的状态
2. 读头所指的符号
3. 下推堆栈栈顶符号

一个输入串能够被PDA所接受的条件：

1. 输入串读完 and 下推栈变空
2. 输入串读完，控制器达到终态

具体定义：

![image-20230120113802568](/img/image-20230120113802568.png)

书上的例子：

![image-20230120115529983](/img/image-20230120115529983.png)

网课的例子：

![image-20230125165433086](/img/image-20230125165433086.png)



### 语法分析程序的操作

网课中的定义：

![image-20230125165646039](/img/image-20230125165646039.png)



书上的版本：

![image-20230120125758186](/img/image-20230120125758186.png)

例子（但是存在问题）：

![image-20230120132924681](/img/image-20230120132924681.png)

![image-20230120132935277](/img/image-20230120132935277.png)

![image-20230120132942226](/img/image-20230120132942226.png)

#### 消除左递归

形如：P->Pa 称为文法左递归

消除直接左递归->例子：

![image-20230120134636228](/img/image-20230120134636228.png)

![image-20230120134814650](/img/image-20230120134814650.png)

间接左递归就先全部化成一个非终结符的表示，然后再消除直接左递归就行了。

#### 消除回溯（预测/提取左因子）

这部分比较复杂。。。

有好多个“集”

##### 终结首符集First(α)

First(α)就是α能推出的所有终结符打头的式子的首字符组成的集合。

处理的时候可以提取公共左因子，让所有候选式的首符集不相交。



### LL(1)文法

LL(n)表示向前看n个字符就能确定。

通过**预测分析程序**和**预测分析表M**进行处理，这种方式属于<u>非递归的预测分析法</u>。

![image-20230125164855030](/img/image-20230125164855030.png)

预测分析程序根据下推栈栈顶符号X和当前读入符号a行事：

![image-20230122130929187](/img/image-20230122130929187.png)

#### 求First集合Follow集

> 为了构造预测分析表，要求这两个集合。
>
> 这边最重要的不是公式，而是理解这两个集是干嘛的，原理是什么。

First集是针对串α而言的。——First(α)

Follow集是针对非终结符A而言的。——Follow(A)

First(α)是α的所有可能推导出的开头的终结符或者空所组成的集合。

Follow(A)是指在**所有句型**中紧跟在A之后的终结符的集合。

求First集算法如下：

![image-20230122133526803](/img/image-20230122133526803.png)

求follow集的文法如下：

![image-20230125153021488](/img/image-20230125153021488.png)



#### 构造预测分析表

算法思想如下：

![image-20230125154526657](/img/image-20230125154526657.png)

如果文法G的分析表M不含有多重定义项，则称G为LL(1)文法，LL(1)文法是无二义性的。

存在如下定理，其实就是说明无重定义项：

![image-20230125154734155](/img/image-20230125154734155.png)



#### 状态表

其实就是分析预测表不写产生式，写产生式序号。

例子：

![image-20230125160309649](/img/image-20230125160309649.png)

![image-20230125160346320](/img/image-20230125160346320.png)



### 递归下降分析法（比较重要）

好像llvm对接的那个例子使用的就是<u>递归下降分析器</u>。

> 其实上面那个使用状态表进行分析的，就是非递归的预测分析法，也叫表驱动的预测分析。

网课里的例子：

![image-20230125163946980](/img/image-20230125163946980.png)

![image-20230125164026133](/img/image-20230125164026133.png)

<u>简单来说就是：</u>

如果是终结符，就匹配，不然就报错。

如果是非终结符，就调用对应的函数。

非终结符的处理函数类似：

![image-20230125164527804](/img/image-20230125164527804.png)

<u>递归和非递归的对比：</u>

![image-20230125165826778](/img/image-20230125165826778.png)



### 预测分析中的错误检测

两种情况下可以检测到错误：

1. 栈顶的终结符和当前输入符号不匹配
2. 栈顶非终结符与当前输入符号在预测分析表对应项中的信息为空

#### 错误恢复

<u>恐慌模式</u>：忽略输入中的一些符号，直到输入中出现由设计者选定的**同步词法单元**集合中的某个词法单元。

例如：在分析A的时候出现错误，可以把FOLLOW(A)中的所有终结符放入非终结符A的同步记号集合。

如果终结符在栈顶而不能匹配，直接弹出就好。

一个具体的例子如下：

![image-20230208132334558](/img/image-20230208132334558.png)

![image-20230208132606985](/img/image-20230208132606985.png)





### 总结: 预测分析法的实现步骤

![image-20230125170003698](/img/image-20230125170003698.png)



### 

## 第五章 自底向上语法分析

简单来说：将输入串w归约成文法开始符号S的过程。

通用方式：<u>移入归约分析（shift-reduce parsing）</u>

> 自顶向下的语法分析采用最左推导
>
> 自底向下采用最左归约方式（反向构造最右推导）



### 移入-归约分析

例子如下：

![image-20230208142313343](/img/image-20230208142313343.png)

##### 句柄

每次归约的符号串称为句柄。

##### 规范句型

栈内符号串+剩余输入=**规范句型**

#### 移入归约分析器的4种动作

1. 移入：将下一个输入符号移入栈顶
2. 归约：归约栈顶的串->某个非终结符
3. 接收：语法分析完成
4. 报错：发现语法错误，并尝试恢复

#### 移入归约分析中的关键问题

造成错误的原因：错误地识别了句柄。

<u>更改句柄的定义</u>：句型的最左直接短语。

**<u>因此自底向下的关键就在于如何正确的识别句柄。</u>**





### LR分析法

L: 对输入进行从左到右的扫描。

R: 反向构造出一个最右推导序列。

LR(k)分析：需要向前查看k个输入符号的LR分析(一般来说查看1个就足够了)

![image-20230208143934352](/img/image-20230208143934352.png)

#### LR分析器(自动机)的总体结构

![image-20230208144038860](/img/image-20230208144038860.png)

#### LR分析器的工作流程

![image-20230208144752684](/img/image-20230208144752684.png)

![image-20230208144809304](/img/image-20230208144809304.png)

![image-20230208145007966](/img/image-20230208145007966.png)

LR分析算法非常简洁，因此关键点在于**<u>LR分析表的构造</u>**。

不同的LR分析法有不同的LR分析表构造方法。



### LR(0)分析

##### LR(0)项目

右部某位置标有圆点的产生式称为相应文法的一个LR(0)项目。

![image-20230212222030486](/img/image-20230212222030486.png)

项目描述了句柄识别的状态。

*产生式A->ε只生成一个项目A->·*



##### 增广文法

就是新加一个开始符号S'和产生式S'->S而得到的文法。

![image-20230212222450624](/img/image-20230212222450624.png)

引入增广文法的目的：使得文法开始符号仅仅出现在一个产生式的左边，从而使得分析器只有一个接受状态：

![image-20230227151243248](/img/image-20230227151243248.png)

##### 后继项目

定义：同属于一个产生式的项目，但是圆点在后面一格。

例：

![image-20230227151452457](/img/image-20230227151452457.png)





##### LR(0)自动机

通过把相同状态合并成一个闭包的方式来构造自动机的状态。

寻找等价项目，就是看等待的符号是否相同。<u>【项目中，圆点后是非终结符，则存在等价项目】</u>

所有的等价项目组成一个**项目集(I)**，称为**项目集闭包**，每个闭包对应着自动机的一个状态。

例子【这个图要自己能画出来就行了】：

![image-20230212223140640](/img/image-20230212223140640.png)



### LR(0)分析表的生成

需要两个关键函数：

1. CLOSURE()函数

   用于计算给定项目集I的闭包

   ![image-20230227152643578](/img/image-20230227152643578.png)

2. GOTO()函数

   用于返回项目集I对应于文法符号X的后继项目集闭包。

   ![image-20230227152847142](/img/image-20230227152847142.png)

##### 1. 构造LR(0)自动机的状态集

构造算法如下：

![image-20230227153038338](/img/image-20230227153038338.png)

##### 2. 构造LR(0)分析表

算法如下：

![image-20230227153207755](/img/image-20230227153207755.png)



##### 移进/归约冲突 & 归约/归约冲突

在LR(0)分析的过程中可能存在这2种冲突。

例：

![image-20230227153552049](/img/image-20230227153552049.png)

第一个项目要求归约，而第二个项目要求移入。

如果没有语法分析动作冲突，才能成为LR(0)文法。

说明：<u>上下文无关文法CFG不总是LR(0)文法。</u>



### SLR分析

基本思想：向后看一个元素，<u>利用Follow集来处理冲突</u>。又称SLR(1)，S代表Simple。

**要求：<u>移进的符号和待约项目的FOLLOW集互不相交</u>，在FOLLOW集中才归约。**

![image-20230228163351688](/img/image-20230228163351688.png)

##### 分析表构造算法

与LR(0)分析表类似，**唯一不同的是归约项目的处理**：

![image-20230228163728192](/img/image-20230228163728192.png)

SLR分析中也会存在冲突。



### LR(1)分析法

基础：在特定位置，A的后继符集合只能是Follow(A)的一个子集（SLR归约时只判定了在不在FOLLOW集中，扩大了可以归约的范围）。

##### LR(1)项目

![image-20230228164701576](/img/image-20230228164701576.png)

##### 等价LR(1)项目

这边有点绕的。

![image-20230228164835804](/img/image-20230228164835804.png)

##### LR(1)自动机

只要能画出这个图，就算基本理解了。

例子：

![image-20230228165700454](/img/image-20230228165700454.png)

##### LR(1)项目集闭包的计算

要对LR(0)的计算方法进行修改：

![image-20230228170037078](/img/image-20230228170037078.png)

![image-20230228170051563](/img/image-20230228170051563.png)

##### LR(1)分析表的构造算法

重点在于对归约项目的处理上：

![image-20230228170208055](/img/image-20230228170208055.png)



### LALR分析法

*(Look Ahead LR)*

目的：为了减少LR(1)分析的项目集闭包数量。

寻找具有相同核心的LR(1)项目集，然后合并。

例：

![image-20230228170640940](/img/image-20230228170640940.png)

但是也可能产生冲突。

![image-20230228171132055](/img/image-20230228171132055.png)

##### 特点

形式上和LR(1)相同

大小上与LR(0)/SLR相当

![image-20230228171305130](/img/image-20230228171305130.png)



### 二义性文法中的LR分析

。。















## 第六章 语法制导翻译

















## 编写一个编译器前端对接LLVM

这个环境最好是选用linux，不然太麻烦了还搞不出来。

### 1. 词法分析Lexer

### 2. 语法分析Parser









